"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearIns = exports.getIns = exports.Octo = void 0;
const helper_1 = require("./helper");
const url_join_1 = __importDefault(require("url-join"));
class Octo {
    constructor({ repo, branch, path = '', token, customPath = '', customUrl = '' }, ctx) {
        this.username = '';
        this.password = '';
        this.clientId = '';
        this.clientSecret = '';
        this.owner = '';
        this.repo = '';
        this.branch = '';
        this.path = '';
        this.token = '';
        this.customUrl = '';
        this.baseUrl = 'https://gitee.com/api/v5';
        this.uploadOptions = function (url, method, content, msg) {
            return {
                method: method,
                json: true,
                resolveWithFullResponse: true,
                url: url,
                formData: {
                    access_token: this.token,
                    content: content,
                    message: msg,
                    branch: this.branch
                }
            };
        };
        this.fileOptions = function (fileName) {
            return encodeURI(url_join_1.default(this.baseUrl, 'repos', this.owner, this.repo, 'contents', this.path, fileName));
        };
        const [owner, r] = repo.split('/');
        if (!r)
            throw new Error('Error in repo name');
        this.owner = owner;
        this.repo = r;
        this.branch = branch || 'master';
        this.token = token;
        this.customUrl = customUrl;
        this.ctx = ctx;
        this.path = helper_1.getPath(path, customPath);
    }
    async getTree(sha) {
        const url = url_join_1.default(this.baseUrl, 'repos', this.owner, this.repo, 'git/gitee/trees', sha);
        // this.ctx.log.info('url:' + url)
        let params = {
            method: 'GET',
            json: true,
            resolveWithFullResponse: true,
            url: url,
            qs: {
                access_token: this.token
            }
        };
        let result = await this.ctx.Request.request(params);
        // this.ctx.log.info('getTree result')
        // this.ctx.log.info(JSON.stringify(result.body))
        if (result && result.statusCode === 200) {
            const { tree } = result.body;
            return tree;
        }
        else {
            this.ctx.log.error('getTree error');
            this.ctx.log.error(JSON.stringify(result));
            throw result;
        }
    }
    async getPathTree() {
        const { path } = this;
        let tree = await this.getTree(this.branch);
        const arr = path.split('/').filter(each => each);
        let sha = this.branch;
        for (let i = 0; i < arr.length; i++) {
            const item = tree.filter(each => arr[i].endsWith(each.path))[0];
            if (!item)
                return Promise.reject(new Error(`Can\'t find ${path}`));
            sha = item.sha;
            tree = await this.getTree(sha);
        }
        return { sha, tree };
    }
    async getDataJson() {
        const defaultRet = {
            lastSync: '',
            data: []
        };
        const { tree } = await this.getPathTree();
        /* this.ctx.log.info('tree info')
        tree.forEach(element => {
          this.ctx.log.info(JSON.stringify(element))
        }) */
        const dataJson = tree.filter(each => each.path === 'data.json')[0];
        // this.ctx.log.info('dataJson info')
        // this.ctx.log.info(JSON.stringify(dataJson))
        if (dataJson) {
            const url = url_join_1.default(this.baseUrl, 'repos', this.owner, this.repo, 'git/blobs', dataJson.sha);
            // this.ctx.log.info('url:' + url)
            const params = {
                method: 'GET',
                json: true,
                resolveWithFullResponse: true,
                url: url,
                qs: {
                    access_token: this.token
                }
            };
            let result = await this.ctx.Request.request(params);
            // this.ctx.log.info('getBlob result')
            // this.ctx.log.info(JSON.stringify(result.body))
            if (result && result.statusCode === 200) {
                const buf = Buffer.from(result.body.content, result.body.encoding);
                const json = JSON.parse(buf.toString());
                return Object.assign(Object.assign(Object.assign({}, defaultRet), json), { sha: dataJson.sha });
            }
            else {
                this.ctx.log.error('getBlob error');
                this.ctx.log.error(JSON.stringify(result));
                throw result;
            }
        }
        return defaultRet;
    }
    async updateDataJson({ data, sha }) {
        const fileName = 'data.json';
        const url = this.fileOptions(fileName);
        // this.ctx.log.info('updateDataJson url:' + url)
        const params = this.uploadOptions(url, 'PUT', Buffer.from(JSON.stringify(data)).toString('base64'), `Sync dataJson by PicGo at ${helper_1.getNow()}`);
        params.formData['sha'] = sha;
        // this.ctx.log.info(JSON.stringify(params))
        let result = await this.ctx.Request.request(params);
        // this.ctx.log.info('sync update data.json')
        // this.ctx.log.info(JSON.stringify(result))
        if (result && result.statusCode === 200) {
            return true;
        }
        else {
            this.ctx.log.error('sync update data.json error');
            this.ctx.log.error(JSON.stringify(result));
            throw result;
        }
    }
    async createDataJson(data) {
        const fileName = 'data.json';
        const url = this.fileOptions(fileName);
        // this.ctx.log.info('createDataJson url:' + url)
        const params = this.uploadOptions(url, 'POST', Buffer.from(JSON.stringify(data)).toString('base64'), `Sync dataJson by PicGo at ${helper_1.getNow()}`);
        let result = await this.ctx.Request.request(params);
        /* this.ctx.log.info('sync data.json')
        this.ctx.log.info(JSON.stringify(result)) */
        if (result && result.statusCode === 201) {
            return true;
        }
        else {
            this.ctx.log.error('sync data.json error');
            this.ctx.log.error(JSON.stringify(result));
            throw result;
        }
    }
    async upload(img) {
        // 取出对象中同名的属性并赋值，神奇的写法，可以取出多个
        const { fileName } = img;
        const url = this.fileOptions(fileName);
        // this.ctx.log.info('url:' + url)
        const params = this.uploadOptions(url, 'POST', img.base64Image || Buffer.from(img.buffer).toString('base64'), `Upload ${fileName} by picGo - ${helper_1.getNow()}`);
        let result = await this.ctx.Request.request(params);
        /* this.ctx.log.info('upload result')
        this.ctx.log.info(JSON.stringify(result)) */
        if (result && result.statusCode === 201) {
            return {
                // result.body.content.download_url
                imgUrl: this.parseUrl(result.body.content.name),
                sha: result.body.content.sha
            };
        }
        else {
            this.ctx.log.error('upload error');
            this.ctx.log.error(JSON.stringify(result));
            throw result;
        }
    }
    async removeFile(img) {
        const ctx = this.ctx;
        const url = this.fileOptions(img.fileName);
        const params = {
            method: 'DELETE',
            json: true,
            resolveWithFullResponse: true,
            url: url,
            qs: {
                access_token: this.token,
                sha: img.sha,
                message: `Deleted ${img.fileName} by picGo - ${helper_1.getNow()}`,
                branch: this.branch
            }
        };
        let result = await this.ctx.Request.request(params);
        /* this.ctx.log.info('Deleted result')
        this.ctx.log.info(JSON.stringify(result)) */
        if (result && result.statusCode === 200) {
            return true;
        }
        else {
            this.ctx.log.error('deleted error');
            this.ctx.log.error(JSON.stringify(result));
            return result;
        }
    }
    parseUrl(fileName) {
        const { owner, repo, path, customUrl, branch } = this;
        if (customUrl) {
            return url_join_1.default(customUrl, path, fileName);
        }
        return url_join_1.default(`https://gitee.com/`, owner, repo, 'raw', branch, path, fileName);
    }
}
exports.Octo = Octo;
let ins = null;
let _cacheOption = '';
function getIns(config, ctx) {
    const str = JSON.stringify(config);
    if (ins && _cacheOption === str)
        return ins;
    _cacheOption = str;
    ins = new Octo(config, ctx);
    return ins;
}
exports.getIns = getIns;
/* istanbul ignore next */
function clearIns() {
    // just for test
    ins = null;
}
exports.clearIns = clearIns;
